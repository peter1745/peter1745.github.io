<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js theme">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Mono Embedding for Game Engines</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-40851481-2"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'UA-40851481-2');
        </script>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/pagetoc.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "theme";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('theme')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="introduction/about-mono.html"><strong aria-hidden="true">1.1.</strong> About Mono</a></li><li class="chapter-item expanded "><a href="introduction/building-mono.html"><strong aria-hidden="true">1.2.</strong> Building Mono</a></li><li class="chapter-item expanded "><a href="introduction/necessary-files.html"><strong aria-hidden="true">1.3.</strong> Getting the Necessary Files</a></li></ol></li><li class="chapter-item expanded "><a href="first-steps/runtime-setup.html"><strong aria-hidden="true">2.</strong> First Steps</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="first-steps/loading-assemblies.html"><strong aria-hidden="true">2.1.</strong> Loading Assemblies</a></li><li class="chapter-item expanded "><a href="first-steps/testing-assembly-loading.html"><strong aria-hidden="true">2.2.</strong> Testing Assembly Loading</a></li><li class="chapter-item expanded "><a href="first-steps/classes.html"><strong aria-hidden="true">2.3.</strong> Classes</a></li><li class="chapter-item expanded "><a href="first-steps/methods.html"><strong aria-hidden="true">2.4.</strong> Methods</a></li><li class="chapter-item expanded "><a href="first-steps/fields.html"><strong aria-hidden="true">2.5.</strong> Fields and Properties</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Mono Embedding for Game Engines</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<h2 id="about-me"><a class="header" href="#about-me">About Me</a></h2>
<p>Hi, my name is Peter, and I'm a game engine developer from Sweden, I'm also the author of this guide. I've been working on a game engine called <a href="https://www.hazelengine.com/">Hazel</a> for over a year, and one of the things I've worked on is a C# scripting engine, using the Mono library.</p>
<p>Hazel is not my own personal engine, and it was originally created by <a href="https://thecherno.com/">Yan Chernikov</a>. I joined the project in September of 2020 as a volunteer, and now I'm lucky enough to be able to work on it as an actual job.</p>
<h2 id="the-goal-of-this-guide"><a class="header" href="#the-goal-of-this-guide">The goal of this guide</a></h2>
<p>The goal of this guide is to help you embed the <a href="https://www.mono-project.com/">Mono</a> library into your game engine. For the past few months I've been working on rewriting the C# scripting engine in Hazel, and I kept getting frustrated because there's very little in terms of useful documentation on how to use Mono in the scope of a game engine.</p>
<p>Yes, Mono <em>does</em> have a documentation site for embedding: <a href="http://docs.go-mono.com/?link=root%3a%2fembed">http://docs.go-mono.com/</a>, but in my experience it's all but useless. There are a few open source (or at least source available) projects out there that have embedded Mono, but there's no real <em>documentation</em> available.</p>
<p><strong>So</strong>, that's why I decided to create this guide. I've been through the pain of googling for hours to figure out how to do something in Mono, and I figured I could help spare others from that pain.</p>
<p>Before we get started I just wanted to say that this guide is <strong>not</strong> a guide on building a complete scripting engine, it's just meant to give you the knowledge you <em>need</em> to write a scripting engine.</p>
<p>I will also mention that the &quot;First Steps&quot; section only covers the very basics, I'll go into way more depth and show more complex code in a more advanced section later on.</p>
<h2 id="credits"><a class="header" href="#credits">Credits</a></h2>
<p>I'm not the only person who has contributed to this. I've had some help with certain parts of it, so I wanted to make sure to mention anyone that has helped out.</p>
<ul>
<li><strong>Marca</strong>, provided build instructions for Mac OSX</li>
</ul>
<h2 id="the-game-engine-series"><a class="header" href="#the-game-engine-series">The Game Engine Series</a></h2>
<p>As I've mentioned this guide <em>isn't</em> meant to teach you how to write a fully fledged scripting engine. But there <em>is</em> a series on YouTube that <em>does</em> cover writing a scripting engine in C++, the <a href="https://www.youtube.com/playlist?list=PLlrATfBNZ98dC-V-N3m0Go4deliWHPFwT">Game Engine Series</a> from <a href="https://www.youtube.com/c/TheChernoProject">The Cherno</a>.</p>
<p>The scripting engine that he's writing is based on the scripting engine that I wrote for Hazel, and he does reference this guide as well. I highly recommend watching the C# scripting related episodes if you're interested in how you can design an actual scripting API.</p>
<p>Understandably there's a <em>lot</em> of different ways of writing a scripting engine, and there's no &quot;correct&quot; way of doing so, although there are worse ways and better ways, as with everything.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="about-mono"><a class="header" href="#about-mono">About Mono</a></h1>
<h2 id="what-is-mono"><a class="header" href="#what-is-mono">What <em>is</em> Mono?</a></h2>
<p>I would assume that you already know what Mono is since you decided to check out this guide, but I'll give a short explanation just in case.</p>
<p>In short: Mono is an open source implementation of Microsoft's <a href="https://en.wikipedia.org/wiki/.NET_Framework">.NET Framework</a>. It was originally designed to bring .NET languages (mostly C#) to platforms other than Windows.
Nowadays it's not strictly necessary for cross-platform support, since Microsoft has been working on making .NET cross-platform natively. But Mono is still very useful for scripting engines, because unlike .NET Core, or .NET Framework, it provides a decent C/C++ API for embedding a .NET runtime.</p>
<h2 id="multiple-versions-of-mono"><a class="header" href="#multiple-versions-of-mono">Multiple versions of Mono?</a></h2>
<p>Now, there are actually <em>two</em> versions of Mono, there's what I call &quot;Classic Mono&quot;, which is mainly what we'll be covering here, then there's what I call the &quot;.NET Core Mono&quot;. I won't get into the differences between .NET Core and .NET Framework, but the biggest difference is that classic Mono only supports up to C# 7, or .NET Framework 4.7.2, where as .NET Core Mono supports the latest version of C#, and is developed as part of the .NET Runtime project.</p>
<p>Both versions of Mono are developed by Microsoft, but classic Mono isn't <em>integrated</em> into .NET, where as .NET Core Mono <em>is</em>. I will eventually cover building the .NET Core version of Mono as well, but I'll start by covering classic Mono because it's simpler, and more suited for game engines (I'll explain why later on).</p>
<h2 id="why-not-use-the-net-core-version"><a class="header" href="#why-not-use-the-net-core-version">Why not use the .NET Core version?</a></h2>
<p>So, why aren't we going to use the .NET Core version of Mono? Simply put: It doesn't support <em>assembly reloading</em>. If you don't know what C# assemblies are I'd recommend you read up a bit on them, but they're essentially a DLL file that contains all your code, converted to an intermediate language (commonly referred to as &quot;IL&quot; or &quot;Bytecode&quot;).</p>
<p>So why does assembly reloading matter in this case? Because when you, or anyone else, is writing C# scripts you want the changes you make to the code to take effect in the engine (or editor) immediately, without having to restart the entire editor / game. And in order to do so we first have to unload the old assembly, and load in the new one, without restarting the program.</p>
<p>And in its current state the .NET Core version of Mono doesn't support unloading C# assemblies, where as classic Mono does. When I was initially rewriting the scripting engine for Hazel I wanted to use the .NET Core version because it would've meant that we could support the latest C# version. And unfortunately I only discovered that assembly unloading wasn't supported about 3 months into rewriting the scripting engine...</p>
<p>As it was I got in touch with the developers of Mono to ask them if it was possible to reload assemblies in any way, and they told me no. So I asked them if they knew <em>when</em> that would be supported, and they told me they didn't know... (Yes, I may still be <em>slightly</em> annoyed with them for releasing the .NET Core version without assembly reloading support)</p>
<p>But <strong>when</strong> the .NET Core version supports assembly reloading I'll make sure to update this book with instructions on how to use that version of Mono (assuming I remember doing so).</p>
<p>But regardless, let's move on to cloning Mono from GitHub, and building the necessary libraries in the next chapter!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-mono"><a class="header" href="#building-mono">Building Mono</a></h1>
<p>Building Mono isn't too hard, but it's a large library, taking up quite a lot of space on your computer, so it will probably take some time to clone, and build it.</p>
<h2 id="platforms"><a class="header" href="#platforms">Platforms</a></h2>
<p>Here are some links to the instructions for each platform:</p>
<ul>
<li><a href="introduction/building-mono.html#windows">Windows</a></li>
<li><a href="introduction/building-mono.html#linux">Linux (Coming Soon!)</a></li>
<li><a href="introduction/building-mono.html#macosx">Mac OSX</a></li>
</ul>
<h2 id="cloning-from-github"><a class="header" href="#cloning-from-github">Cloning from GitHub</a></h2>
<p>Before we can build Mono, we have to clone it from GitHub. You should hopefully know how to do this yourself, but I know <em>someone</em> won't know how to do that so I'm including this section anyway.</p>
<p>If you don't need a step-by-step guide for this, you should just clone <a href="https://github.com/mono/mono">https://github.com/mono/mono</a>.</p>
<p>Alright, in order to clone Mono make sure you have a Git client installed, I'll be providing commands for the command-line git client, but you could also use a GUI client.</p>
<p>In order to clone Mono from the command line, you just run <code>git clone https://github.com/mono/mono</code>, that's it. Yeah I know, this section feels pointless but might as well include it.</p>
<h2 id="building-classic-mono-from-source"><a class="header" href="#building-classic-mono-from-source">Building classic Mono from source</a></h2>
<p>Now we get to the fun part: building Mono from source. Mono is a pretty large project so building Mono can take a bit of time. I'll provide build instructions for Windows, MacOS and Linux (I'll be using Linux Mint when building).</p>
<p>I'll provide the pre-requisites that you'll need to build Mono on the specified platform as to save you some thinking power and pain.</p>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>Building Mono on Windows is <em>ridiculously</em> easy, most likely easier than any other platform. I will note that using Visual Studio only works for building the Mono runtime libraries, not the .NET libraries (e.g <code>System.dll</code>, <code>System.Collections.Generic.dll</code>, etc...).</p>
<p>In my case I won't be building the .NET libraries from source, I'll be getting them by installing Mono locally and copying them from the install directory.</p>
<p>If you want to build the .NET libraries you'll need access to the <code>make</code> command, which you can use by running a <a href="https://www.cygwin.com/">Cygwin</a> shell.</p>
<h4 id="pre-requisites"><a class="header" href="#pre-requisites">Pre Requisites</a></h4>
<ul>
<li>An installed copy of Mono (might not be required but it's good to have just in case)</li>
<li>Visual Studio (I'll be using Visual Studio 2022)</li>
<li>Cygwin or some other tool that let's you use <code>make</code> (Only needed if you want to build the .NET libraries)</li>
</ul>
<h4 id="building"><a class="header" href="#building">Building</a></h4>
<p>In order to build Mono you just need to navigate to <code>mono/msvc/</code> and open up <strong>mono.sln</strong> in Visual Studio. All you need to do now is select the build configuration and the platform to build for.</p>
<p>I recommend building both the <code>Release</code> and the <code>Debug</code> configuration since only building <code>Release</code> will mean you'll have an even harder time debugging Mono related issues. If you want to build 64-bit or 32-bit doesn't really matter for the sake of this guide, but these days you really don't need to support 32-bit platforms.
After that just start the build and let it run!</p>
<p>If you've done everything correctly (which I assume you have since it's not hard building Mono on Windows) you can move on to the &quot;Getting the Necessary Files&quot; chapter.</p>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<p><strong>Coming Soon!</strong></p>
<h3 id="macosx"><a class="header" href="#macosx">MacOSX</a></h3>
<p>Building Mono on Mac is very similar to Linux, you still use <code>make</code> and <code>autogen</code>.</p>
<h4 id="pre-requisites-1"><a class="header" href="#pre-requisites-1">Pre-Requisites</a></h4>
<ul>
<li>An installed copy of Mono (only if you don't get <code>monolite</code>)</li>
<li>Make</li>
</ul>
<h4 id="building-1"><a class="header" href="#building-1">Building</a></h4>
<p>The first step is to open a terminal and navigate to the root <code>mono</code> folder.</p>
<p>Before you continue, keep in mind that running <code>./autogen.sh</code> will cause Mono to clone all the submodules that it will need to build, this process takes quite a long time. Once you're in the root Mono folder you'll want to start by running this command: <code>./autogen.sh --prefix=&lt;absolutePathToDesiredOutputDirectory&gt; --disable-nls</code>.</p>
<p>Once that command has finished, you'll want to either install Mono locally, or get <code>monolite</code>. If you have Mono installed locally, just continue to the next step, if you want to use <code>monolite</code> however, you'll have to run: <code>make get-monolite-latest</code> in order to get it.</p>
<p>Once you have Mono or <code>monolite</code> you'll want to run <code>make</code>, and then <code>make install</code> to build Mono.</p>
<p>All the necessary libraries should've been placed in the folder you specified as part of the <code>--prefix</code> flag.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-the-necessary-files"><a class="header" href="#getting-the-necessary-files">Getting the Necessary Files</a></h1>
<p>Now it's time for us to get all the necessary files that we'll need to embed the Mono runtime. This includes the Mono libraries and the .NET libraries. Naturally the files are called different things and located in different places depending on the platform, but I'll provide the necessary files and locations for Windows, MacOSX and Linux.</p>
<p>You can use these links to quickly jump to your platform:</p>
<ul>
<li><a href="introduction/necessary-files.html#windows">Windows</a></li>
<li><a href="introduction/necessary-files.html#linux">Linux (Coming Soon!)</a></li>
<li><a href="introduction/necessary-files.html#macosx">Mac OSX</a></li>
</ul>
<h2 id="windows-1"><a class="header" href="#windows-1">Windows</a></h2>
<h3 id="native-libraries"><a class="header" href="#native-libraries">Native Libraries</a></h3>
<p>All of Mono's native libraries should've been built into <code>mono-root/msvc/build/sgen/{platform}/</code>, where <code>{platform}</code> is either <code>x64</code> or <code>Win32</code>.</p>
<p>In that folder you'll see three other folders called <code>bin</code>, <code>lib</code> and <code>obj</code>, we're only interested in the <code>bin</code> and <code>lib</code> folders.
Both of those will have either one or two subfolders based on if you built both <code>Release</code> and <code>Debug</code>, or only <code>Release</code> or only <code>Debug</code>.</p>
<p>I will only be telling you <em>what</em> files you'll need, how <em>you</em> choose to structure your projects dependencies is up to you.</p>
<p>So, here's the native libraries that you'll need from <code>lib</code>:</p>
<ul>
<li>eglib.lib</li>
<li>libgcmonosgen.lib</li>
<li>libmini-sgen.lib</li>
<li>libmonoruntime-sgen.lib</li>
<li>libmono-static-sgen.lib</li>
<li>libmonoutils.lib</li>
<li>mono-2.0-sgen.lib</li>
<li>MonoPosixHelper.lib</li>
</ul>
<p>You're also going to need some files from the <code>bin</code> folder, these files will have to be placed next to your applications executable. These are the DLL files you'll need from <code>bin</code>:</p>
<ul>
<li>mono-2.0-sgen.dll</li>
<li>MonoPosixHelper.dll</li>
</ul>
<h3 id="net-libraries"><a class="header" href="#net-libraries">.NET Libraries</a></h3>
<p>You don't technically <strong>have</strong> to copy the .NET libraries into your own program, you can tell the Mono runtime where they're located, but I like having them be a part of the project, so I'll be copying them.</p>
<p>I won't be providing a full list of the files that you'll need, there's a lot of them, instead I'll just tell you what folders you'll need to copy.</p>
<p>If you've installed Mono locally (not just cloned it) you'll have to navigate to the folder where you installed it, in my case I installed it to <code>C:\Program Files\Mono</code>. Inside that install folder you'll want to navigate to <code>lib/mono</code>, and you should see a bunch of folders that have numbers, and some that have an <code>-api</code> postfix.</p>
<p>The main folder you'll want is the one called <code>4.5</code>, just make sure you copy it into a <code>lib</code> folder, located inside of a folder called <code>mono</code>. In my case it would be <code>D:\dev\MyGameEngine\MyEditor\mono\lib</code>.
I may end up covering the other folders at a later date, but I have only recently started experimenting with them myself so I don't want to provide incorrect information here.</p>
<p>If you built the .NET libraries from source you'll have to navigate to <code>mono-root/mcs/class/corlib</code>, and you <em>should</em> find the same folders there. I haven't done this myself so I could be incorrect, if so please open an issue in the GitHub repo for this page. Located here: <a href="https://github.com/peter1745/peter1745.github.io">https://github.com/peter1745/peter1745.github.io</a>.</p>
<h3 id="header-files"><a class="header" href="#header-files">Header Files</a></h3>
<p>Getting the correct header files is really easy, they're located in <code>mono-root/msvc/include/</code>. You'll probably want to copy the <code>mono</code> folder, so that when you go to include a Mono header file you type <code>#include &lt;mono/somedir/somefile.h&gt;</code>.</p>
<p>That's it! You've now got all the files you'll need to embed the Mono runtime.</p>
<p>Before we continue I will say that <em>most</em> of the time you'll only need to link with <code>mono-2.0-sgen.lib</code>, but you should still keep the other .lib files around in case you need them later on, or you can delete them if you want to minimize the size of your project as much as possible.</p>
<p>Also remember to at the very least copy <code>mono-2.0-sgen.dll</code> to the same folder as your applications executable.</p>
<h2 id="linux-1"><a class="header" href="#linux-1">Linux</a></h2>
<p><strong>Coming Soon!</strong></p>
<h2 id="macosx-1"><a class="header" href="#macosx-1">MacOSX</a></h2>
<h3 id="native-libraries-1"><a class="header" href="#native-libraries-1">Native Libraries</a></h3>
<p>All the necessary native libraries you'll need should be located in the output folder that you specified when you built Mono. You'll find a folder called <code>lib</code> in there, that's where the libraries are located.</p>
<p>So, here's the native libraries that you'll need from <code>lib</code>:</p>
<ul>
<li>libeglib.a</li>
<li>libmonoutils.a</li>
<li>libMonoPosixHelper.dylib</li>
<li>libmonosgen-2.0.dylib (This is most likely a symlink for libmonosgen-2.0.1.dylib)</li>
</ul>
<h3 id="net-libraries-1"><a class="header" href="#net-libraries-1">.NET Libraries</a></h3>
<p>You don't technically <strong>have</strong> to copy the .NET libraries into your own program, you can tell the Mono runtime where they're located, but I like having them be a part of the project, so I'll be copying them.</p>
<p>I won't be providing a full list of the files that you'll need, there's a lot of them, instead I'll just tell you what folders you'll need to copy.</p>
<p>If you've installed Mono locally (not just cloned it) you'll have to navigate to the folder where you installed it. Inside that install folder you'll want to navigate to <code>lib/mono</code>, and you should see a bunch of folders that have numbers, and some that have an <code>-api</code> postfix.</p>
<p>The main folder you'll want is the one called <code>4.5</code>, just make sure you copy it into a <code>lib</code> folder, located inside of a folder called <code>mono</code>.
I may end up covering the other folders at a later date, but I have only recently started experimenting with them myself so I don't want to provide incorrect information here.</p>
<p>If you built the .NET libraries from source you'll have to navigate to the output directory that you specified when you built Mono, and navigate to <code>lib/mono/</code>, and you <em>should</em> find the same folders there. I haven't done this myself so I could be incorrect, if so please open an issue in the GitHub repo for this page. Located here: <a href="https://github.com/peter1745/peter1745.github.io">https://github.com/peter1745/peter1745.github.io</a>.</p>
<h3 id="header-files-1"><a class="header" href="#header-files-1">Header Files</a></h3>
<p>Getting the correct header files is really easy, they're located in <code>include/</code> in the output directory you specified when you built Mono. You'll probably want to copy the <code>mono</code> folder, so that when you go to include a Mono header file you type <code>#include &lt;mono/somedir/somefile.h&gt;</code>.</p>
<p>That's it! You've now got all the files you'll need to embed the Mono runtime.</p>
<p>Before we continue I will say that <em>most</em> of the time you'll only need to link with <code>libmonosgen-2.0.dylib</code>, but you should still keep the other files around in case you need them later on, or you can delete them if you want to minimize the size of your project as much as possible.</p>
<h2 id="all-done"><a class="header" href="#all-done">All Done!</a></h2>
<p>Alright, now you should have all the necessary files, and your project <em>should</em> be configured correctly, but if you don't know how to e.g link the Mono libraries to your project, or add the include directory, well, then <em>maybe</em> you shouldn't be considering embedding Mono just yet.</p>
<p>Once you've got your project configured and linking with Mono, feel free to move on to the &quot;Setting up the Runtime&quot; section of this guide!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-the-runtime"><a class="header" href="#setting-up-the-runtime">Setting up the Runtime</a></h1>
<p>Now that we've built Mono, gotten all the necessary files, and <em>hopefully</em> setup our project correctly, it's time to start coding! The very first thing we have to do is initialize the Mono runtime.</p>
<p>In order to properly initialize Mono we have to start by including <code>mono/jit/jit.h</code>, and <code>mono/metadata/assembly.h</code>. Once that's done we have to let Mono know where the .NET libraries are located. The function we'll have to call is <code>mono_set_assemblies_path</code>. Keep in mind that the path provided to this function have to either be an absolute path (e.g <code>D:\dev\Engine\mono\lib</code>), or a path relative to the current working directory (e.g <code>mono/lib</code>).</p>
<p>So in my case it would look like this:</p>
<pre><code class="language-cpp">void InitMono()
{
    mono_set_assemblies_path(&quot;mono/lib&quot;);
}
</code></pre>
<p>If you don't provide this path to Mono you'll see an error message printed in the console, it would look something like this:
<img src="first-steps/../res/mscorlib-error.jpg" alt="MSCorlibError" /></p>
<p>I will say that if you don't provide this path, but you have a <strong>MONO_PATH</strong> environment variable that points to the correct folder Mono will attempt to use that path to located <code>mscorlib.dll</code>.</p>
<p>Once we've told Mono where it can locate mscorlib we can actually start the runtime. We have to call <code>mono_jit_init</code> in order to start the runtime, but you may notice that there's actually another function with a similiar name: <code>mono_jit_init_version</code>, so what's the difference?
Well the difference has to do with what version of the runtime we use. By using the first function (<code>mono_jit_init</code>) we're telling Mono to use the runtime version referenced by the <em>first</em> assembly that we load, meaning it will automatically detect it. If we use the second function <code>mono_jit_init_version</code> we can specify the <em>exact</em> version of the runtime we want.</p>
<p>From my experimentation what function we use doesn't have much of an effect, and it's generally speaking safer to let Mono automatically pick the runtime version, so for this guide we'll be using <code>mono_jit_init</code>. We must make sure to give this function a string when calling it, this string essentially represents the name of the runtime.</p>
<p>When calling this function we get a <code>MonoDomain</code> pointer, it's important that we store that pointer since we have to manually clean it up later on. The interesting thing is that Mono actually stores this pointer internally as well, and according to the Mono developers it doesn't really make sense that we have to keep track of that pointer as well, but that's just the way it is, so make sure to store it somewhere.</p>
<pre><code class="language-cpp">void InitMono()
{
    mono_set_assemblies_path(&quot;mono/lib&quot;);

    MonoDomain* rootDomain = mono_jit_init(&quot;MyScriptRuntime&quot;);
    if (rootDomain == nullptr)
    {
        // Maybe log some error here
        return;
    }

    // Store the root domain pointer
    s_RootDomain = rootDomain;
}
</code></pre>
<p>And that's the basics of initializing the Mono runtime. Naturally as we continue to develop our scripting engine further the initialization process will get more complex, but we'll cover the necessary parts when they're needed.</p>
<p>Now we're not quite done with the initialization, before we can load our C# assembly and start running code we have to create an <a href="https://docs.microsoft.com/en-us/dotnet/framework/app-domains/application-domains">App Domain</a>.</p>
<h2 id="creating-an-app-domain"><a class="header" href="#creating-an-app-domain">Creating an App Domain</a></h2>
<p>Mono makes it trivially easy to create a new App Domain, all we have to do is call <code>mono_domain_create_appdomain</code> and give our App Domain a name. Remember to store the <code>MonoDomain</code> pointer returned by this function somewhere, we'll need it later on. This process will become slightly more complicated in the future but for now we'll just modify our initalization function to look like this:</p>
<pre><code class="language-cpp">void InitMono()
{
    mono_set_assemblies_path(&quot;mono/lib&quot;);

    MonoDomain* rootDomain = mono_jit_init(&quot;MyScriptRuntime&quot;);
    if (rootDomain == nullptr)
    {
        // Maybe log some error here
        return;
    }

    // Store the root domain pointer
    s_RootDomain = rootDomain;

    // Create an App Domain
    s_AppDomain = mono_domain_create_appdomain(&quot;MyAppDomain&quot;, nullptr);
    mono_domain_set(s_AppDomain, true);
}
</code></pre>
<p>You may wonder what the second parameter of <code>mono_domain_create_appdomain</code> is, well it allows us to pass a path to a configuration file. We won't be needing this so we can simply pass <code>nullptr</code>.</p>
<p>Once we've got our <code>MonoDomain</code> pointer we have to set our new App Domain to be the <em>current</em> App Domain, we can do this by calling <code>mono_domain_set</code> and pass our domain. The second parameter simply indicates if we want to force our domain to be set as the current domain. In reality we could probably pass <code>false</code> here since all that parameter does is forcibly set the App Domain even if it's being unloaded, but we'll just go ahead and pass <code>true</code>.</p>
<p>Now that we've created our AppDomain we can finally start working towards running C# code from C++! All we have to do now is load a C# assembly, which we'll cover in the next section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loading-assemblies"><a class="header" href="#loading-assemblies">Loading Assemblies</a></h1>
<p>In this section we'll cover how you can load a C# assmebly using Mono. First of all you should know that an assembly in C# (and in .NET in general) can be <em>either</em> a DLL or an EXE file. Now before we start writing the loading code we have to have an assembly to load.</p>
<p>In this example we'll be building our C# project as a Dynamic Link Library, or DLL, Visual Studio calls the project type for DLLs &quot;Class Library&quot; so make sure your C# project has the &quot;Output Type&quot; set to &quot;Class Library&quot;, as shown in the image below:</p>
<p><img src="first-steps/../res/vs-project-type.jpg" alt="VisualStudioProjectType" /></p>
<h2 id="c-code"><a class="header" href="#c-code">C# Code</a></h2>
<p>In the beginning we'll simply write some basic C# code that will allow us to make sure our code actually works. To start I'll create a C# class called &quot;CSharpTester&quot;, and we'll add some basic data and methods to it.</p>
<pre><code class="language-cs">using System;

public class CSharpTesting
{
    public float MyPublicFloatVar = 5.0f;

    public void PrintFloatVar()
    {
        Console.WriteLine(&quot;MyPublicFloatVar = {0:F}&quot;, MyPublicFloatVar);
    }

    private void IncrementFloatVar(float value)
    {
        MyPublicFloatVar += value;
    }

}
</code></pre>
<p>For now we won't actually be running any of this code, but we'll be checking that the class exists in the assembly after we've loaded it. This code will also be used to demonstrate a few things that you need to keep in mind when using Mono.</p>
<p>But for now just go ahead and build your project, you should get a DLL file with your project name somewhere in your project folder, look for a folder called &quot;bin&quot; and you should find it. Remember the file path since we'll need it to load the DLL.</p>
<h2 id="c-code-1"><a class="header" href="#c-code-1">C++ Code</a></h2>
<p>So now it's time for us to write the code that will actually load the C# DLL into Mono. Typically in a game engine you'll have two DLLs that you'll need to load, one that contains the game code, and one that's provided by the engine.</p>
<p>Typically the engine will provide a C# DLL that the game code will link to, this is so that the engine developers can provide a safe API for the user to interact with. Because of this we'll be writing a generic function that will simply load any DLL, this function will take a path to the DLL file as an argument and it will return a pointer to a <code>MonoAssembly</code>.</p>
<p>Now, there's a lot of ways that you can load an assembly using Mono, but the preferred way is to load the file into an array of bytes and then pass that byte array to Mono directly. I'll get into why this is the preferred method later.</p>
<p>I'll also provide a function that can load a file into an array of bytes:</p>
<pre><code class="language-cpp">char* ReadBytes(const std::string&amp; filepath, uint32_t* outSize)
{
    std::ifstream stream(filepath, std::ios::binary | std::ios::ate);
    
    if (!stream)
    {
        // Failed to open the file
        return nullptr;
    }

    std::streampos end = stream.tellg();
    stream.seekg(0, std::ios::beg);
    uint32_t size = end - stream.tellg();
    
    if (size == 0)
    {
        // File is empty
        return nullptr;
    }

    char* buffer = new char[size];
    stream.read((char*)buffer, size);
    stream.close();

    *outSize = size;
    return buffer;
}
</code></pre>
<p>So, here's the code that loads the C# assembly:</p>
<pre><code class="language-cpp">MonoAssembly* LoadCSharpAssembly(const std::string&amp; assemblyPath)
{
    uint32_t fileSize = 0;
    char* fileData = ReadBytes(assemblyPath, &amp;fileSize);

    // NOTE: We can't use this image for anything other than loading the assembly because this image doesn't have a reference to the assembly
    MonoImageOpenStatus status;
    MonoImage* image = mono_image_open_from_data_full(fileData, fileSize, 1, &amp;status, 0);

    if (status != MONO_IMAGE_OK)
    {
        const char* errorMessage = mono_image_strerror(status);
        // Log some error message using the errorMessage data
        return nullptr;
    }

    MonoAssembly* assembly = mono_assembly_load_from_full(image, assemblyPath.c_str(), &amp;status, 0);
    mono_image_close(image);
    
    // Don't forget to free the file data
    delete[] fileData;

    return assembly;
}
</code></pre>
<p>Now I'll go through and explain this code bit by bit. First we read the bytes of the C# assembly into a <code>char*</code> buffer. After that we need to give Mono the data that we loaded, we can do this by calling <code>mono_image_open_from_data_full</code>. The first two parameters should be self-explanatory, it's just the data and the size of the data. The third parameter tells Mono if we want it to copy the data, or if we'll be responsible for storing it, here we pass <code>1</code>, indicating that Mono will copy the data into an internal buffer. The fourth parameter is a pointer to a <code>MonoImageOpenStatus</code> enum, we can use this value to determine if Mono was able to read the data we passed to it, or if there was an issue somewhere.</p>
<p>The last parameter is also a boolean value, and if it's set to true, or <code>1</code>, it means that Mono will load our image in &quot;reflection mode&quot;, meaning we can inspect the types, but not run any code. If you're building an application similiar to JetBrains <a href="https://www.jetbrains.com/decompiler/">dotPeek</a> program you'd most likely want to set this parameter to true, but since we want to <em>run</em> the code we'll set it to false, or <code>0</code>.</p>
<p><code>mono_image_open_from_data_full</code> will return a valid pointer to a <code>MonoImage</code> struct if it successfully interpreted our data, or <code>nullptr</code> if it failed. After we've loaded our data into Mono we'll check that the <code>status</code> variable is set to <code>MONO_IMAGE_OK</code>, and if it's not we'll query Mono for an error message describing what went wrong, we do this using <code>mono_image_strerror</code> which converts our status variable to a more user-friendly error message.</p>
<p>Now that we have a valid image loaded we'll have to create a <code>MonoAssembly</code> from it, luckily this is really easy, we just have to call <code>mono_assembly_load_from_full</code> and give it the image. If this function succeeds we'll get a pointer to a <code>MonoAssembly</code> struct returned, otherwise it'll return <code>nullptr</code>.</p>
<p>The first parameter of this function is the image that we got back from Mono, the second parameter is essentially just a name that Mono can use when printing errors, the third parameter is our <code>status</code> variable again. This function will write to our <code>status</code> variable if there's an error, but at this point there really shouldn't be an error generated so we won't check for it.</p>
<p>The last parameter is the same as the last parameter in <code>mono_image_open_from_data_full</code>, so if you specified <code>1</code> there you should also do that with this function, but in our case we'll set it to <code>0</code>.</p>
<p>After we've retrieved a <code>MonoAssembly</code> pointer from our image we can (and should) close that image, since it's only used for getting a <code>MonoAssembly</code> pointer, and is useless for anything else. I will note that <code>MonoImage</code>s are used for some other things in Mono, and we'll cover that later, but <em>this</em> image is useless so we need to close it to decrease the reference count.</p>
<p>And that's it! But because we're good programmers we'll make sure to free the buffer that we loaded, using <code>delete[] fileData;</code>. After that we can simply return our assembly pointer!</p>
<p>Now you probably want to make sure that the file you're trying to load <em>actually</em> exists, but in this example we're assuming that we'll never try to load a file that doesn't exist on disk.</p>
<p>Alright, now we have a function capable of loading a C# assembly into the Mono runtime, so now it's time to actually load our assembly and verify that our code works, but we'll cover that in the next section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-assembly-loading"><a class="header" href="#testing-assembly-loading">Testing Assembly Loading</a></h1>
<p>So, now we have a function capable of loading a C# assembly. So all we have to do now is make sure it actually works properly. How do we do that? Well, we could of course just check that we get a valid <code>MonoAssembly</code> pointer, but that doesn't strictly mean that everything's working as expected.</p>
<p>In order to properly test it we're going to be iterating over all the class types defined in our assembly, that way we can see exactly what classes, structs and enums are in there. The way we do this is by iterating through the assembly metadata, which we can do by getting access to the type definitions table.</p>
<h2 id="the-code"><a class="header" href="#the-code">The Code</a></h2>
<p>Alright that sounds good in theory, but <em>how</em> do we do that? Well it's surprisingly easy, although the code can look a bit complicated at first.</p>
<pre><code class="language-cpp">void PrintAssemblyTypes(MonoAssembly* assembly)
{
    MonoImage* image = mono_assembly_get_image(assembly);
    const MonoTableInfo* typeDefinitionsTable = mono_image_get_table_info(image, MONO_TABLE_TYPEDEF);
    int32_t numTypes = mono_table_info_get_rows(typeDefinitionsTable);

    for (int32_t i = 0; i &lt; numTypes; i++)
    {
        uint32_t cols[MONO_TYPEDEF_SIZE];
        mono_metadata_decode_row(typeDefinitionsTable, i, cols, MONO_TYPEDEF_SIZE);

        const char* nameSpace = mono_metadata_string_heap(image, cols[MONO_TYPEDEF_NAMESPACE]);
        const char* name = mono_metadata_string_heap(image, cols[MONO_TYPEDEF_NAME]);

        printf(&quot;%s.%s\n&quot;, nameSpace, name);
    }
}
</code></pre>
<h2 id="tables"><a class="header" href="#tables">Tables</a></h2>
<p>And that's how easy it is to iterate through all the type definitions in our assembly! But, what does this code <em>actually</em> do? Well it's actually quite simple, simply put the assembly itself stores all the necessary info about the data it contains in a set of tables, you can find a list of all the tables and their columns <a href="http://docs.go-mono.com/?link=xhtml%3adeploy%2fmono-api-metadata.html">here</a>, scroll down to the &quot;Metadata Tables&quot; section and you'll find a list of them.</p>
<p>Basically what Mono allows us to do is to iterate through all the rows in each table, in the case of the <code>MONO_TABLE_TYPEDEF</code> table each row represents a type, and the columns contains information about that type. We can get a table from an image by making use of <code>mono_image_get_table_info</code>, and passing in the image and the &quot;id&quot; of the table we want.</p>
<p>And as you can see from the code we can get the assembly image from an assembly by calling <code>mono_assembly_get_image</code> and passing in the assembly.</p>
<h2 id="rows-and-columns"><a class="header" href="#rows-and-columns">Rows and Columns</a></h2>
<p>After we have the table that we want to iterate through we have to get the number of rows, or type definitions in this case, in that table, we can do that by calling <code>mono_table_info_get_rows</code> and passing in the table info pointer.</p>
<p>We then loop over all rows, and now we have to get all the column values for each row. All columns store their data as unsigned 32-bit integers, and so we start by allocating a stack array called <code>cols</code>, and setting the size of the array to the maximum number of columns for the table we're iterating. Mono provides us with constants that represent the number we need for each table, so in this case we set the size of the array to <code>MONO_TYPEDEF_SIZE</code>.</p>
<p>In order to populate the array we have to decode the current row in the type definitions table, we can do this by calling <code>mono_metadata_decode_row</code>, and passing in a few parameters, while I think the parameters are self-explanatory I realize that might not be the case for everyone, so I'll go through and explain what each parameter is.</p>
<p>The first parameter is the actual table that we're iterating over. The second parameter is the row whose columns we want to get. The third parameter is simply the columns array that we allocated, and the last parameter is the size of that array.</p>
<p>After we've called this function our <code>cols</code> array will now be populated with a bunch of values, and we can now use those values to get some of the data for this type.</p>
<p>A quick note before I explain the rest of the code: The data stored in this array should be used differently depending on what the column <em>represents</em>, in some cases the value is the value that we want, stored right there in the array, other times the value represents an index into a different data structure somewhere else in memory, in the case of the namespace and name of a given type the columns store indices into the string heap.</p>
<p>So sometimes you'd do what we're doing here, and using the value to get a string from the string heap, and sometimes you'd use the value as-is, the <code>MONO_ASSEMBLYREF_MAJOR_VERSION</code> is a good example of this, if you wanted to get the major version of an assembly you'd have simply do <code>uint32_t majorVersion = cols[MONO_ASSEMBLYREF_MAJOR_VERSION];</code>, assuming you have the correct table.</p>
<h2 id="getting-the-type-name-and-namespace"><a class="header" href="#getting-the-type-name-and-namespace">Getting the Type Name and Namespace</a></h2>
<p>Now that I've explained that bit I'll explain the next two lines in the code, you can see they're almost identical, we call <code>mono_metadata_string_heap</code> for both lines, and we're passing in the image, and some value from the columns.</p>
<p>First we're getting the namespace name by accessing the value stored in the <code>MONO_TYPEDEF_NAMESPACE</code> column, again that value is an <em>index</em> into the string heap, where the name of our namespace is located. If a type doesn't have a namespace, meaning it's in the global namespace, this function will simply return an empty string.</p>
<p>Next we do almost the exact same thing, except we're getting the value in the <code>MONO_TYPEDEF_NAME</code> column.</p>
<p>As you can see from the image below there's still a few other columns in the <code>MONO_TABLE_TYPEDEF</code> table, I'm not going to cover them here right now, but I'll make sure to properly cover them at a later date.</p>
<p><img src="first-steps/../res/typedef-columns.jpg" alt="TypeDefColumns" /></p>
<p><strong>Alright!</strong> If you now call this function (<em>after</em> you've loaded the assembly) you should see all types stored in your assembly printed to the console.</p>
<h2 id="the-module-type"><a class="header" href="#the-module-type">The Module Type</a></h2>
<p>Now you might've noticed that the very first type printed is called <code>&lt;Module&gt;</code>, and you probably realize that there's no type with that name in your project, so what's going on? Well it's actually a type that's provided by the C# compiler, and all C# DLLs and EXEs have this type.</p>
<p>Effectively this type represents your <em>entire</em> assembly, your assembly will <em>always</em> have at least one module, although it's possible to create a <a href="https://docs.microsoft.com/en-us/dotnet/framework/app-domains/multifile-assemblies">Multifile Assembly</a> which is an assembly that contains multiple modules. Regardless that doesn't matter here, because we will never use the <code>&lt;Module&gt;</code> class in this guide, and you'll most likely never have to use it if you're making a scripting engine.</p>
<p>And that's it for this section! If you saw your types printed in the console it's safe to assume that everything works as expected <em>and</em> you've learned a bit more about how C# assemblies stores data, and we can now move on to actually doing something interesting. In the next section we'll be creating an instance of our <code>CSharpTesting</code> class.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-a-reference-to-a-c-class"><a class="header" href="#getting-a-reference-to-a-c-class">Getting a reference to a C# class</a></h1>
<p>So in order for us to call methods and access properties on a C# class from C++ we first have to get a reference to that class, and create an instance of it.</p>
<p>There are many ways of getting a reference to a C# class but the simplest is by making use of the <code>mono_class_from_name</code> function, which lets us get a class by name.</p>
<p>So lets say we want to get a reference to our <code>CSharpTesting</code> class, in that case our code would look something like this:</p>
<pre><code class="language-cpp">MonoClass* GetClassInAssembly(MonoAssembly* assembly, const char* namespaceName, const char* className)
{
    MonoImage* image = mono_assembly_get_image(assembly);
    MonoClass* klass = mono_class_from_name(image, namespaceName, className);

    if (klass == nullptr)
    {
        // Log error here
        return nullptr;
    }

    return klass;
}

// ...

MonoClass* testingClass = GetClassInAssembly(appAssembly, &quot;&quot;, &quot;CSharpTesting&quot;);

</code></pre>
<h2 id="creating-an-instance-from-our-class"><a class="header" href="#creating-an-instance-from-our-class">Creating an instance from our class</a></h2>
<p>Once we have our class we have to actually instantiate it. Instantiating a class involves two steps, first we have to allocate the object, then we have to call the correct constructor. Let's start by taking a look at the code, there are however some things we have to keep in mind with constructors that I'll cover at a later date.</p>
<pre><code class="language-cpp">// Get a reference to the class we want to instantiate
MonoClass* testingClass = GetClassInAssembly(appAssembly, &quot;&quot;, &quot;CSharpTesting&quot;);

// Allocate an instance of our class
MonoObject* classInstance = mono_object_new(s_AppDomain, testingClass);

if (classInstance == nullptr)
{
    // Log error here and abort
}

// Call the parameterless (default) constructor
mono_runtime_object_init(classInstance);
</code></pre>
<p>As you can see Mono makes it very easy to instantiate a C# class from C++.</p>
<h3 id="explaining-the-code"><a class="header" href="#explaining-the-code">Explaining the Code</a></h3>
<p>First we retrieve our C# class, after that we have to <em>allocate</em> the instance of that class. Now remember, allocating a class and constructing a class are two very different things, allocating simply means allocating enough memory to hold all of the class data, and constructing means calling one of the classes constructors, which will initialize all the fields and properties stored in the class.</p>
<p>We allocate an instance of the class by calling <code>mono_object_new</code>, and we pass two parameters: first we pass the AppDomain that we created when we initialized Mono, remember this isn't the domain we got back from <code>mono_jit_init</code>, it's AppDomain we explicitly created. Secondly we pass the actual class that we want to allocate an instance of. If everything goes they way we want it to we should end up with a new instance of that class, although <code>mono_object_new</code> <em>can</em> return nullptr.</p>
<p>Keep in mind that this instance is effectively <em>useless</em> until we've actually called the constructor.</p>
<p>After we've allocated the instance we now have to call the constructor, or <em>initialize</em> the instance. There is however a pretty big design problem we have to solve though: Classes can have <em>multiple</em> constructors. So which one do we call? Well the simplest way of solving this issue is to either know beforehand what constructors any given class will have, or we can simply enforce a requirement that <em>all</em> classes that will be constructible from C++ *<em>have</em> to have a parameterless constructor.</p>
<p>In Hazel we use both of these approaches, for most classes we assume they will have a parameterless constructor, but we support constructors that take any number of parameters as well.</p>
<p>For this simple example we'll assume that all classes have a parameterless constructor though. And don't worry if you haven't explicitly added a parameterless constructor, if you don't provide any constructors at all the C# compiler will automatically generate a constructor without parameters for you. If you do provide a constructor that has parameters you will however have to create a parameterless constructor explicitly.</p>
<p>So what does <code>mono_runtime_object_init</code> actually do? Well it simply tries to call the parameterless constructor for the class instance that you give it. If it can't find a parameterless constructor it will assert, so we'll eventually have to manually check if the parameterless constructor exists.</p>
<p>Once we've called that function our <code>MonoObject</code> will be completely initialized and ready to be used, but before we get to that I'll explain what we have to keep in mind when constructing C# objects.</p>
<p>Now understandably for a proper scripting engine you'd want to be able to search through the entire C# assembly and effectively get a list of what scripts you can instantiate, and have everything be a bit more dynamic. But again this guide isn't teaching you how to write a scripting engine, it's simply giving you the knowledge about Mono that you'll need to write a scripting engine.</p>
<p>If you're really interested in writing a proper scripting engine I'd highly recommend checking out the <a href="https://www.youtube.com/playlist?list=PLlrATfBNZ98dC-V-N3m0Go4deliWHPFwT">Game Engine Series</a> from <a href="https://www.youtube.com/c/TheChernoProject">The Cherno</a> on YouTube. He does make some use of this guide for reference.</p>
<p>In the next section we'll be covering how to call C# methods from C++!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-c-methods-from-c"><a class="header" href="#calling-c-methods-from-c">Calling C# Methods from C++</a></h1>
<p>Alright, now that we've got an instance of a C# class, it's time to call some methods. It's important to note that Mono gives us two ways of calling C# methods: <code>mono_runtime_invoke</code> and Unmanaged Method Thunks. This section will only cover <code>mono_runtime_invoke</code>, but I will definitely cover Unmanaged Methods Thunks later. I will however go over the differences between the two in this section.</p>
<h2 id="mono_runtime_invoke-vs-unmanaged-method-thunks"><a class="header" href="#mono_runtime_invoke-vs-unmanaged-method-thunks"><code>mono_runtime_invoke</code> vs. Unmanaged Method Thunks</a></h2>
<p>So, what's the difference? Well the difference is mainly in <em>how</em> Mono actually ends up calling the method in question, and also <em>what</em> parameters you can pass in.
Using <code>mono_runtime_invoke</code> is slower compared to Unmanaged Method Thunks, but it's also <em>safe</em> and more flexible. <code>mono_runtime_invoke</code> can invoke <em>any</em> method with <em>any</em> parameters, and from what I understand <code>mono_runtime_invoke</code> also does a lot more error checking and validation on the object you pass, as well as the parameters.</p>
<p>Unmanaged Method Thunks are <em>technically</em> called &quot;Unmanaged to Managed Thunks&quot;, but I call them &quot;Unmanaged Method Thunks&quot; because I accidentially misread the name once. Unmanaged Method Thunks is a concept added in version 2 of Mono, and they allow you to call C# methods with far less overhead compared to <code>mono_runtime_invoke</code>, this means that if you're calling a C# method many times a second, so maybe you have an <code>OnUpdate</code> method in C# that you're calling 60 - 144 times per second, you'd want to create an Unmanaged to Managed Thunk.</p>
<p>Effectivley Unmanaged to Managed Thunks create a custom invokation method (e.g a custom &quot;trampoline&quot;) from unmanaged to managed code, and that invokation method is specific to the method signature you gave it, meaning there is no ambiguity as to what parameters can be passed in.</p>
<p>So, when should you use <code>mono_runtime_invoke</code> and when should you use Unmanaged Method Thunks? Well it depends. If you don't know the signature of the method at compile time (C++ compile time) then you have should probably use <code>mono_runtime_invoke</code>, although you <em>can</em> use Unmanaged Method Thunks as well, but generally for those you want the parameters to be known at compile time.</p>
<p>A general rule of thumb is that if you're calling a C# method several times (more than 10 I'd say) per second, and you know the signature of that method at compile time you should use Unmanaged Method Thunks.</p>
<p>If you don't know the method signature at compile time or if you're only calling the method every now and then instead of several times per second you probably want to go with <code>mono_runtime_invoke</code>.</p>
<h2 id="retrieving-and-invoking-a-c-method"><a class="header" href="#retrieving-and-invoking-a-c-method">Retrieving and Invoking a C# Method</a></h2>
<p>Alright, now that we understand the difference between <code>mono_runtime_invoke</code> and Unmanaged Method Thunks it's finally time to get a reference to the C# method we want to call.</p>
<p>There are a lot of different ways to get a reference to a C# method, and the method you'll use entirely depends on if you're parsing the C# assembly and you don't know what methods are going to be in there beforehand, and one for if you already know the method name and signature, as well as what class it belongs to, before you even load the assembly.</p>
<p>In this case we'll be using the manual way of getting references to methods, but we will cover the more dynamic way later on. Alright, with that out of the way it's time to take a look at the code.</p>
<h3 id="the-code-1"><a class="header" href="#the-code-1">The Code</a></h3>
<pre><code class="language-cpp">MonoObject* InstantiateClass(const char* namespaceName, const char* className)
{
    // Get a reference to the class we want to instantiate
    MonoClass* testingClass = GetClassInAssembly(s_AppAssembly, &quot;&quot;, &quot;CSharpTesting&quot;);

    // Allocate an instance of our class
    MonoObject* classInstance = mono_object_new(s_AppDomain, testingClass);

    if (classInstance == nullptr)
    {
        // Log error here and abort
    }

    // Call the parameterless (default) constructor
    mono_runtime_object_init(classInstance);
}

void CallPrintFloatVarMethod(MonoObject* objectInstance)
{
    // Get the MonoClass pointer from the instance
    MonoClass* instanceClass = mono_object_get_class(objectInstance);

    // Get a reference to the method in the class
    MonoMethod* method = mono_class_get_method_from_name(instanceClass, &quot;PrintFloatVar&quot;, 0);

    if (method == nullptr)
    {
        // No method called &quot;PrintFloatVar&quot; with 0 parameters in the class, log error or something
        return;
    }

    // Call the C# method on the objectInstance instance, and get any potential exceptions
    MonoObject* exception = nullptr;
    mono_runtime_invoke(method, objectInstance, nullptr, &amp;exception);

    // TODO: Handle the exception
}

// ...
MonoObject* testInstance = InstantiateClass(&quot;&quot;, &quot;CSharpTesting&quot;);
CallPrintFloatVarMethod(testInstance);
</code></pre>
<h3 id="explaining-the-code-1"><a class="header" href="#explaining-the-code-1">Explaining the Code</a></h3>
<p>Alright, as you can see I've taken the code from the previous section and wrapped it in a function for convenience. But what we're interested in is the <code>CallPrintFloatVarMethod</code> function, which will call (or <em>invoke</em>) the <code>PrintFloatVar</code> on the instance of the <code>CSharpTesting</code> class. Remember that methods are stored inside classes, but you <em>invoke</em> them on an <em>instance</em> of that class. Essentially all C# methods have an implicit parameter that references the instance of the class that the method is being called on, which is effectively what let's us use the <code>this</code> keyword. Luckily we don't have to pass that as an explicit parameter in Mono, but it's good to properly understand how it works behind the scenes.</p>
<p>The first thing we do before calling the method is getting a <code>MonoClass</code> pointer <em>from</em> the class instance, we could also pass the class to the C++ function if we wanted to. We can get the class by calling <code>mono_object_get_class</code> and passing in the <code>MonoObject</code> pointer as the only parameter.</p>
<p>Next we actually need to get a reference to the C# method, or <code>MonoMethod</code>, and as with everything in Mono we get it as a pointer. The function we use to get the pointer is <code>mono_class_get_method_from_name</code>. <em>Yes I know, Mono can be very verbose...</em> The first parameter we need to pass is the class that the method belongs to, it's worth nothing that if the method doesn't actually exist in the class the function will return <code>nullptr</code>. The second parameter is the name of the method we want to get.</p>
<p>Lastly we need to tell Mono how many parameters the method has. If it doesn't have any we simply pass 0, or we could optionally pass -1 in which case Mono will simply return the first version of the method that it finds.</p>
<p>It's important to note that if there's multiple versions of the method that has the same number of parameters this function won't work properly, since it doesn't check the actual <em>signature</em> of the method, just that it has the correct number of parameters. There are ways to get methods by a specific signature though, we'll cover that later as well.</p>
<p>Alright, now that we've got a reference to the C# method we can actually invoke it, which as I explained in the first part of this article we can do by calling <code>mono_runtime_invoke</code>.</p>
<p>But before we call that you can see that I've declared a pointer to a <code>MonoObject</code> and called it <code>exception</code>, as well as assigned it to <code>nullptr</code>. Why? Well it's because if the method we call throws an exception our scripting engine would probably want to know about that so we can e.g log that exception to a console window or something along those lines.</p>
<p>If the method throws an exception <code>mono_runtime_invoke</code> will populate that <code>MonoObject</code> with the exception <em>instance</em>, which we can then use to get information about what went wrong.</p>
<p>So now that I've explained that, what are all the parameters of <code>mono_runtime_invoke</code>? The first parameter is simply the pointer to the C# method that we want to invoke. The second parameter is the class <em>instance</em> that we want to call the method on. The third parameter is a pointer to an array of any parameters we want to pass in, but since <code>PrintFloatVar</code> doesn't take any parameters we can simply pass <code>nullptr</code>.</p>
<p>And the last parameter is a pointer to the <code>MonoObject*</code> we declared on the previous line, it's the memory address of our <code>exception</code> variable. If you don't care about exceptions at this time you can just pass <code>nullptr</code> and Mono will ignore that parameter.</p>
<p>It's also worth noting that <code>mono_runtime_invoke</code> can actually return something to us. A <code>MonoObject*</code> in fact. This is useful if the method you're calling returns something and you want to retrieve and do something with that return value in C++. If the method is marked as <code>void</code> then <code>mono_runtime_invoke</code> will simply return <code>nullptr</code>.</p>
<p>Our method doesn't return anything so we won't bother dealing with that for now, but don't worry I'll be sure to cover this as well.</p>
<h2 id="passing-parameters-to-a-method"><a class="header" href="#passing-parameters-to-a-method">Passing Parameters to a Method</a></h2>
<p>Now that we can call C# methods that don't return anything or take any parameters, I think it's time to learn how we can pass parameters to C# methods from C++. Before we get started I will say that passing parameters often times involves &quot;Marshalling&quot; the data between unmanaged and managed memory. I won't go into too much detail about <em>what</em> marshalling is, or how Mono handles it, but <a href="https://mark-borg.github.io/blog/2017/interop/">this</a> article explains it in a pretty good way, so I highly recommend reading it if you're interested in learning more. I also recommend reading <a href="https://www.mono-project.com/docs/advanced/embedding/#exposing-c-code-to-the-cil-universe:~:text=For%20example%2C%20passing,the%20marshalling%20attributes">this</a> example of marshalling in Mono specifically.</p>
<p>It's important to note that Mono will almost never handle marshalling for us, meaning we will need to do some manual type checking and coversions later on, for now we'll just be passing a simple float, which doesn't need to be marshalled in the first place.</p>
<h3 id="the-code-2"><a class="header" href="#the-code-2">The Code</a></h3>
<pre><code class="language-cpp">void CallIncrementFloatVarMethod(MonoObject* objectInstance, float value)
{
    // Get the MonoClass pointer from the instance
    MonoClass* instanceClass = mono_object_get_class(objectInstance);

    // Get a reference to the method in the class
    MonoMethod* method = mono_class_get_method_from_name(instanceClass, &quot;IncrementFloatVar&quot;, 1);

    if (method == nullptr)
    {
        // No method called &quot;IncrementFloatVar&quot; with 1 parameter in the class, log error or something
        return;
    }

    // Call the C# method on the objectInstance instance, and get any potential exceptions
    MonoObject* exception = nullptr;
    void* param = &amp;value;
    mono_runtime_invoke(method, objectInstance, &amp;param, &amp;exception);

    // OR

    MonoObject* exception = nullptr;
    void* params[] =
    {
        &amp;value
    };

    mono_runtime_invoke(method, objectInstance, params, &amp;exception);

    // TODO: Handle the exception
}

// ...
MonoObject* testInstance = InstantiateClass(&quot;&quot;, &quot;CSharpTesting&quot;);
CallIncrementFloatVarMethod(testInstance, 5.0f);
</code></pre>
<h3 id="explaining-the-code-2"><a class="header" href="#explaining-the-code-2">Explaining the Code</a></h3>
<p>Alright, as you can see the code is very similar to when we didn't pass any parameters, so I won't explain all the code <em>again</em>. You can see that in the first example we declare a variable of type <code>void*</code> called <code>param</code>, and simply assign it to the memory address of <code>value</code>. The reason we do this, and the reason why it's fine to assign it to hold the memory address of a temporary value, is because <code>mono_runtime_invoke</code> has to be capable of accepting <em>any</em> parameter type, and Mono is a C library meaning templates are out of the question.</p>
<p>In our simple case Mono will most likely just copy the data stored at that memory address directly into managed memory, since it's a simple float. Keep in mind that some types may require us to manually marshal the data, either by constructing an instance of a C# class, or by converting a C-style string to a <code>MonoString*</code> and passing that.</p>
<p>I'll be sure to cover how we can handle these cases later on.</p>
<p>In the second example we don't just declare a <code>void*</code>, but rather an <em>array</em> of <code>void*</code>. We would do this if we need to pass multiple parameters to the method, and we'd have to make sure that the array stores the parameters in the same order that they're declared in the method signature.</p>
<p>If you're wondering how Mono knows what the size of the data array that we pass is, it's simply because it expects the total size of that array to equal the size of <em>all</em> the parameters in the C# method, meaning if the array size doesn't match the parameter count you will end up with problems, and Mono <em>may</em> not tell you about it.</p>
<p>And that's the basics of how we can retrieve and invoke C# methods from C++! I will obviously go into more depth about parameter types and how we can convert between C++ types and C# types later on.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fields-and-properties"><a class="header" href="#fields-and-properties">Fields and Properties</a></h1>
<p>In this section we'll cover how we can get a reference to, and interact with <em>both</em> C# fields and properties. The only reason why I'll cover properties alongside fields is because Mono let's us interact with properties as if they were regular fields (almost), even though properties are essentially just syntactical sugar around a field and 2 methods.</p>
<p>If you want to read up more on properties in C# check <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/properties">this</a> article from the Microsoft Docs.</p>
<p>Now as with most things in Mono there's several ways of getting a reference to a C# field or property, and which one you'll use depends on if you want to iterate through all fields and properties, or if you want to get any specific field or property. It's also important to note that as with methods we don't get a field or property from an instance of class, but rather from the class itself, and then we simply access the field or property <em>using</em> the class instance.</p>
<p>Alright now that we understand that it's time to take a look at the code, you'll probably notice that I've changed the C# class code a bit.</p>
<h2 id="getting-references-to-fields-and-properties"><a class="header" href="#getting-references-to-fields-and-properties">Getting References to Fields and Properties</a></h2>
<pre><code class="language-cs">using System;

public class CSharpTesting
{
    public float MyPublicFloatVar = 5.0f;

    private string m_Name = &quot;Hello&quot;;
    public string Name
    {
        get =&gt; m_Name;
        set
        {
            m_Name = value;
            MyPublicFloatVar += 5.0f;
        }
    }

    public void PrintFloatVar()
    {
        Console.WriteLine(&quot;MyPublicFloatVar = {0:F}&quot;, MyPublicFloatVar);
    }

    private void IncrementFloatVar(float value)
    {
        MyPublicFloatVar += value;
    }

}
</code></pre>
<p>And on the C++ side of things:</p>
<pre><code class="language-cpp">MonoObject* testingInstance = InstantiateClass(&quot;&quot;, &quot;CSharpTesting&quot;);
MonoClass* testingClass = mono_object_get_class(testingInstance);

// Get a reference to the public field called &quot;MyPublicFloatVar&quot;
MonoClassField* floatField = mono_class_get_field_from_name(testingClass, &quot;MyPublicFloatVar&quot;);

// Get a reference to the private field called &quot;m_Name&quot;
MonoClassField* nameField = mono_class_get_field_from_name(testingClass, &quot;m_Name&quot;);

// Get a reference to the public property called &quot;Name&quot;
MonoProperty* nameProperty = mono_class_get_property_from_name(testingClass, &quot;Name&quot;);

// Do something

</code></pre>
<h3 id="explanation"><a class="header" href="#explanation">Explanation</a></h3>
<p>Now we have some <em>very</em> basic code that allows us to get a reference to all the fields an properties we want.</p>
<p>Before I show you how we can interact with them I want to take a moment to explain something: Mono does <strong>not</strong> care about the accessibility of classes, methods, fields or properties that we want to access.</p>
<p>Do you want to set the value of a private field? Mono let's you. Want to set a private property to <code>null</code> in the middle of an update loop and crash the entire application? You can do that. Mono does <em>not</em> care.</p>
<p>Which of course means that it's <em>our</em> responsibility to respect the accessibility of all of those. Now, I'm not saying that you should completely ignore non-public fields or properties, it can be very useful to be able to access those for debuggability reasons.</p>
<p>But what I <em>am</em> saying is that your scripting engine should <em>never</em> be able to set the value of a non-public field or property <em>unless</em> the writer of that code explicitly allows it.</p>
<p>You can for an example add a C# attribute that the user can add to their private fields that tells the scripting engine that it can set the value of that field, in Hazel we have an attribute called <code>ShowInEditor</code> which allows the engine to set the value of that field. Unity has <code>SerializeField</code> which does the same.</p>
<p>Alright, now let's see how we can get e.g the accessibility of the fields and properties that we just retrieved.</p>
<h2 id="checking-accesibility"><a class="header" href="#checking-accesibility">Checking Accesibility</a></h2>
<pre><code class="language-cpp">
enum class Accessibility : uint8_t
{
    None = 0,
    Private = (1 &lt;&lt; 0),
    Internal = (1 &lt;&lt; 1),
    Protected = (1 &lt;&lt; 2),
    Public = (1 &lt;&lt; 3)
};

// Gets the accessibility level of the given field
uint8_t GetFieldAccessibility(MonoClassField* field)
{
    uint8_t accessibility = (uint8_t)Accessibility::None;
    uint32_t accessFlag = mono_field_get_flags(field) &amp; MONO_FIELD_ATTR_FIELD_ACCESS_MASK;

    switch (accessFlag)
    {
        case MONO_FIELD_ATTR_PRIVATE:
        {
            accessibility = (uint8_t)Accessibility::Private;
            break;
        }
        case MONO_FIELD_ATTR_FAM_AND_ASSEM:
        {
            accessibility |= (uint8_t)Accessibility::Protected;
            accessibility |= (uint8_t)Accessibility::Internal;
            break;
        }
        case MONO_FIELD_ATTR_ASSEMBLY:
        {
            accessibility = (uint8_t)Accessibility::Internal;
            break;
        }
        case MONO_FIELD_ATTR_FAMILY:
        {
            accessibility = (uint8_t)Accessibility::Protected;
            break;
        }
        case MONO_FIELD_ATTR_FAM_OR_ASSEM:
        {
            accessibility |= (uint8_t)Accessibility::Private;
            accessibility |= (uint8_t)Accessibility::Protected;
            break;
        }
        case MONO_FIELD_ATTR_PUBLIC:
        {
            accessibility = (uint8_t)Accessibility::Public;
            break;
        }
    }

    return accessibility;
}

// Gets the accessibility level of the given property
uint8_t GetPropertyAccessbility(MonoProperty* property)
{
    uint8_t accessibility = (uint8_t)Accessibility::None;
    
    // Get a reference to the property's getter method
    MonoMethod* propertyGetter = mono_property_get_get_method(property);
    if (propertyGetter != nullptr)
    {
        // Extract the access flags from the getters flags
        uint32_t accessFlag = mono_method_get_flags(propertyGetter, nullptr) &amp; MONO_METHOD_ATTR_ACCESS_MASK;

        switch (accessFlag)
        {
            case MONO_FIELD_ATTR_PRIVATE:
            {
                accessibility = (uint8_t)Accessbility::Private;
                break;
            }
            case MONO_FIELD_ATTR_FAM_AND_ASSEM:
            {
                accessibility |= (uint8_t)Accessbility::Protected;
                accessibility |= (uint8_t)Accessbility::Internal;
                break;
            }
            case MONO_FIELD_ATTR_ASSEMBLY:
            {
                accessibility = (uint8_t)Accessbility::Internal;
                break;
            }
            case MONO_FIELD_ATTR_FAMILY:
            {
                accessibility = (uint8_t)Accessbility::Protected;
                break;
            }
            case MONO_FIELD_ATTR_FAM_OR_ASSEM:
            {
                accessibility |= (uint8_t)Accessibility::Private;
                accessibility |= (uint8_t)Accessibility::Protected;
                break;
            }
            case MONO_FIELD_ATTR_PUBLIC:
            {
                accessibility = (uint8_t)Accessbility::Public;
                break;
            }
        }
    }

    // Get a reference to the property's setter method
    MonoMethod* propertySetter = mono_property_get_set_method(property);
    if (propertySetter != nullptr)
    {
        // Extract the access flags from the setters flags
        uint32_t accessFlag = mono_method_get_flags(propertySetter, nullptr) &amp; MONO_METHOD_ATTR_ACCESS_MASK;
        if (accessFlag != MONO_FIELD_ATTR_PUBLIC)
            accessibility = (uint8_t)Accessibility::Private;
    }
    else
    {
        accessibility = (uint8_t)Accessibility::Private;
    }

    return accessibility;
}

// ...

MonoObject* testingInstance = InstantiateClass(&quot;&quot;, &quot;CSharpTesting&quot;);
MonoClass* testingClass = mono_object_get_class(testingInstance);

// Get a reference to the public field called &quot;MyPublicFloatVar&quot;
MonoClassField* floatField = mono_class_get_field_from_name(testingClass, &quot;MyPublicFloatVar&quot;);
uint8_t floatFieldAccessibility = GetFieldAccessibility(floatField);

if (floatFieldAccessibility &amp; (uint8_t)Accessibility::Public)
{
    // We can safely write a value to this
}

// Get a reference to the private field called &quot;m_Name&quot;
MonoClassField* nameField = mono_class_get_field_from_name(testingClass, &quot;m_Name&quot;);
uint8_t nameFieldAccessibility = GetFieldAccessibility(nameField);

if (nameFieldAccessibility &amp; (uint8_t)Accessibility::Private)
{
    // We shouldn't write to this field
}

// Get a reference to the public property called &quot;Name&quot;
MonoProperty* nameProperty = mono_class_get_property_from_name(testingClass, &quot;Name&quot;);
uint8_t namePropertyAccessibility = GetPropertyAccessibility(nameProperty);

if (namePropertyAccessibility &amp; (uint8_t)Accessibility::Public)
{
    // We can safely write a value to the field using this property
}

// Do something

</code></pre>
<h3 id="explanation-1"><a class="header" href="#explanation-1">Explanation</a></h3>
<p>Now, I know that was a lot of code, but I <em>highly</em> recommend that you make sure you don't write to non-public variables unless the person who wrote the code allows it, since they probably don't expect the scripting engine to do so normally.</p>
<p>You may notice that we store the accessibility in a bit field, the reason for this is because C# allows you to mark class fields and properties as <code>protected internal</code> or <code>private protected</code>. In which case it's more efficient for us to store e.g both <code>Accessibility::Protected</code> <em>and</em> <code>Accessibility::Internal</code> in the same variable. Now it's entirely possible that you only care if the field / property is <em>public</em> or not, in which case you could just return a bool and call the function e.g <code>IsFieldPublic</code> / <code>IsPropertyPublic</code>.</p>
<h4 id="getfieldaccessibility"><a class="header" href="#getfieldaccessibility">GetFieldAccessibility</a></h4>
<p>So how does <code>GetFieldAccessibility</code> work? Well it's very simple, we start by retrieving all the flags set on the passed field (which stores more than just accessibility data), and then we extract the accessibility data from that by using the bitwise AND operator on the flags and the <code>MONO_FIELD_ATTR_FIELD_ACCESS_MASK</code> mask.</p>
<p>This will give us a value that represents one of these possible access types:</p>
<ul>
<li>MONO_FIELD_ATTR_PRIVATE</li>
<li>MONO_FIELD_ATTR_FAM_AND_ASSEM</li>
<li>MONO_FIELD_ATTR_ASSEMBLY</li>
<li>MONO_FIELD_ATTR_FAMILY</li>
<li>MONO_FIELD_ATTR_FAM_OR_ASSEM</li>
<li>MONO_FIELD_ATTR_PUBLIC</li>
</ul>
<p>You can look at the code if you're curios as to what each of these represents. So, we do a <code>switch</code> on the access flag, and check for each of these values, then simply assign the correct <code>Accessibility</code> value to the <code>accessibility</code> variable depending on which <code>case</code> statement we hit.</p>
<h4 id="getpropertyaccessibility"><a class="header" href="#getpropertyaccessibility">GetPropertyAccessibility</a></h4>
<p>As you can probably tell from the code getting the accessibility of a property isn't <em>quite</em> as easy as getting it from a field. The reason for this is because a property essentially represents two <em>methods</em>. A getter and a setter. Meaning we can't directly query the accessibility of the property, but rather we have to query the accessibility of the <em>methods</em>. This is made even more complicated by the fact that that properties are not <em>required</em> to have <em>both</em> a getter <strong>and</strong> a setter, only one is required. And if you create an auto-property, e.g <code>public string MyProp =&gt; m_MyValue;</code> C# will only generate a getter, not a setter.</p>
<p>So, here's how that works. We start by getting a reference to the getter method, which we can do easily by calling <code>mono_property_get_get_method</code> and passing in the property. We then get the accessibility flags from that getter (if it exists) by calling <code>mono_method_get_flags</code> and passing in the getter method, as well as <code>nullptr</code>. That last parameter simply represents the method implementation flags. If you're curios about what these are you can check <a href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.methodimplattributes?view=netframework-4.7.2">this</a> article. We're passing <code>nullptr</code> because we're not interested in those flags right now.</p>
<p>And just like we did in <code>GetFieldAccessibility</code> we perform a bitwise AND operation to get the accessibility flag, perform a <code>switch</code> on that and store the result in the <code>accessibility</code> variable.</p>
<p>After we've done that we do something similiar with the setter, assuming it exists, the difference is that for the setter we only check if it's <em>not</em> public, in which case we set the <code>accessiblity</code> variable to <code>Accessibility::Private</code>, since we can't write to the property if the setter is private. We also set the accessiblity to private if there is no setter.</p>
<p>Another difference between the getter and setter is that for the setter we obviously have to call <code>mono_property_get_set_method</code> instead of <code>mono_property_get_get_method</code>.</p>
<h2 id="setting-and-getting-values"><a class="header" href="#setting-and-getting-values">Setting and Getting Values</a></h2>
<p>Alright after that very lengthy talk about accessibility it's finally time to set and get some values! Now this is can be a <em>very</em> complex topic, especially when you start dealing with actually marshalling data, we won't be dealing with that too much right now though.</p>
<p>We'll start by getting and setting the value of <code>MyPublicFloatVar</code>, and then we'll move on to doing the same for the <code>Name</code> property.</p>
<pre><code class="language-cpp">bool CheckMonoError(MonoError&amp; error)
{
	bool hasError = !mono_error_ok(&amp;error);
	if (hasError)
	{
		unsigned short errorCode = mono_error_get_error_code(&amp;error);
		const char* errorMessage = mono_error_get_message(&amp;error);
        printf(&quot;Mono Error!\n&quot;);
        printf(&quot;\tError Code: %hu\n&quot;, errorCode);
        printf(&quot;\tError Message: %s\n&quot;, errorMessage);
		mono_error_cleanup(&amp;error);
	}
	return hasError;
}

std::string MonoStringToUTF8(MonoString* monoString)
{
	if (monoString == nullptr || mono_string_length(monoString) == 0)
		return &quot;&quot;;

	MonoError error;
	char* utf8 = mono_string_to_utf8_checked(monoString, &amp;error);
	if (CheckMonoError(error))
		return &quot;&quot;;
	std::string result(utf8);
	mono_free(utf8);
	return result;
}

MonoObject* testingInstance = InstantiateClass(&quot;&quot;, &quot;CSharpTesting&quot;);
MonoClass* testingClass = mono_object_get_class(testingInstance);

MonoClassField* floatField = mono_class_get_field_from_name(testingClass, &quot;MyPublicFloatVar&quot;);

// Get the value of MyPublicFloatVar from the testingInstance object
float value;
mono_field_get_value(testingInstance, floatField, &amp;value);

// Increment value by 10 and assign it back to the variable
value += 10.0f;
mono_field_set_value(testingInstance, floatField, &amp;value);

MonoProperty* nameProperty = mono_class_get_property_from_name(testingClass, &quot;Name&quot;);

// Get the value of Name by invoking the getter method
MonoString* nameValue = (MonoString*)mono_property_get_value(nameProperty, testingInstance, nullptr, nullptr);
std::string nameStr = MonoStringToUTF8(nameValue);

// Modify and assign the value back to the property by invoking the setter method
nameStr += &quot;, World!&quot;;
nameValue = mono_string_new(s_AppDomain, nameStr.c_str());
mono_property_set_value(nameProperty, testingInstance, (void**)&amp;nameValue, nullptr);

</code></pre>
<h3 id="explanation-2"><a class="header" href="#explanation-2">Explanation</a></h3>
<h4 id="fields"><a class="header" href="#fields">Fields</a></h4>
<p>So, there's a lot to unpack here. We'll start with the <code>mono_field_get_value</code> function. It takes three parameters, the first one being the class instance that we want to get the value from, the second one being the field we want to get the value from, and the third being a pointer to a variable that will hold the value C++ side.</p>
<p>One of the most important things you have to understand here is the difference between getting a value type like a float, or an int or even a struct, and getting a reference type like a class.
If you're getting a value type as long as the value isn't boxed, like we're doing, you can simply declare a variable of the C++ equivalent type and pass the memory address of that variable. The size of the C++ type <em>has</em> to match the size of the C# type though, and if you're using a struct the layout has to match as well.</p>
<p>If you're getting a reference type though you have to declare a <code>MonoObject</code> pointer, since reference types are <em>always</em> allocated on the heap.</p>
<p>Alright, with that out of the way we can increment the value and reassign it to the field by calling <code>mono_field_set_value</code>, passing in the class instance, the field and the memory address of the variable, assuming it's a value type.</p>
<p>If you wanted to confirm that the C# field got updated correctly you could simply retrieve the value again and check that. Naturally you'd probably want to have a flexible system set up that will handle these conversions in a better way, and that adds a degree of type-safety since Mono will simply accept the value as long as the size of it matches the C# field, and it will most likely not tell you that anything's wrong.</p>
<h4 id="properties"><a class="header" href="#properties">Properties</a></h4>
<p>Alright, now it's time to get to how we get and set values when dealing with properties, unfortunately it's quite a bit different from dealing with fields. I will not be explaining the <code>CheckMonoError</code> or the <code>MonoStringToUTF8</code> in detail, I'll leave that for later. But in short the <code>MonoStringToUTF8</code> simply takes a <code>MonoString</code> pointer, which simply holds a pointer to the C# managed string, and it then copies that into unmanaged memory and returns an <code>std::string</code>.</p>
<p>And <code>CheckMonoError</code> simply extracts an error code and message from the given <code>MonoError</code> struct and then logs that to the console.</p>
<p>First of all we call <code>mono_property_get_value</code>, which will invoke the properties getter method for us. The first two parameters are simply the property itself and the class instance. The last two parameters, where we pass nullptr represent any parameters that the getter method might expect, and lastly a pointer to a <code>MonoException*</code> that we can get back from the method in case it throws one. The third parameter doesn't really make sense in my opinion since a property's getter method <em>can't</em> take any parameters that I'm aware of, so I'll always pass <code>nullptr</code>.</p>
<p>As you can see we're getting a string, and because of that we simply get a pointer to a <code>MonoString</code> struct, which holds a pointer to the C# string, in managed memory. It's important to note that <code>mono_property_get_value</code> returns a <code>MonoObject</code> pointer, which in the case of a string should simply be cast to a <code>MonoString</code> pointer.</p>
<p>In the case of e.g a value type it will return the value boxed inside a <code>MonoObject</code>, meaning we'll have to unbox it. I <em>highly</em> recommend you read up on boxing and unboxing <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing">here</a>.</p>
<p>But since in this case we're getting a string we simply cast it, and then convert it to an <code>std::string</code>. As you can see we do use <code>mono_string_to_utf8_checked</code>, and I wanted to mention that if there is a &quot;checked&quot; version of a Mono function available you should <strong>always</strong> use that one, and <strong>never</strong> the unchecked version. This function also returns a pointer to a buffer, and we're in charge of freeing it after we're done with it. So keep that in mind.</p>
<p>If you want to see how to deal with unboxing value types like floats, see the code I've written below.</p>
<p>Alright, now that we've got our string and we've modified it, it's time to assing it back to C#. As I'm sure you're aware we're doing a <em>lot</em> of copying here, but don't worry too much about it since you most likely won't be getting and setting C# values from C++ every frame.</p>
<p>In order to invoke the setter function of the property we call <code>mono_property_set_value</code>, and just like with the getter we pass the property and the class instance. Then we have to pass the value itself. The last parameter is again a pointer to a <code>MonoObject*</code>, which will contain any exceptions thrown by the setter. I'm passing <code>nullptr</code> here again.</p>
<p>The important thing to understand about <code>mono_property_set_value</code> is that you <em>cannot</em> pass the memory address of value types directly like you can with <code>mono_field_set</code>. This function will crash if you do.</p>
<p>What you need to do instead is create an array of <code>void*</code> and store the address in that array. I'm not sure why this is the case but it is. So you'd something along the lines of <code>void* data[] = { &amp;myValueTypeData };</code> and then pass that array like this: <code>mono_property_set_value(prop, instance, data, nullptr);</code>.</p>
<p>In the case of a <code>MonoObject*</code> or a <code>MonoString*</code> you can simply pass the memory address and cast it to a <code>void**</code>. Although I do recommend going with the <code>void*</code> array approach, since that works at all times.</p>
<p>You can probably tell that in the example above we call <code>mono_string_new</code>, and pass the AppDomain as well as the C string in order to construct a new <code>MonoString</code>. We do this because we can't, and shouldn't attempt to modify the <code>MonoString</code> we got from the property, I won't go into <em>too</em> much detail on strings because I'll cover them in-depth later on.</p>
<h3 id="dealing-with-value-types-and-properties"><a class="header" href="#dealing-with-value-types-and-properties">Dealing with Value Types and Properties</a></h3>
<pre><code class="language-cpp">MonoProperty* floatProperty = mono_class_get_property_from_name(testingClass, &quot;MyFloatProperty&quot;);

// Get the value of Name by invoking the getter method
MonoObject* floatValueObj = mono_property_get_value(floatProperty, testingInstance, nullptr, nullptr);
float floatValue = *(float*)mono_object_unbox(floatValueObj);

// Modify and assign the value back to the property by invoking the setter method
floatValue += 10.0f;
void* data[] = { &amp;floatValue };
mono_property_set_value(nameProperty, testingInstance, data, nullptr);
</code></pre>
<p>Alright! Now we're done with the <em>basics</em> of fields and properties. <em>Yes, I know it's ironic that I call this the basics considering the length of this article but it's important that you really understand how it works</em>.</p>
<p>There is so much more that I'd like to cover when it comes to dealing with fields and properties, but I have to restrain myself or this article will be 50,000 paragraphs. In the next section we'll cover Internal Calls, which will allow C# code to call C++ functions.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="theme/pagetoc.js"></script>

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>